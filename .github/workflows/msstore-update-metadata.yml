name: Microsoft Store - Update Metadata

on:
  workflow_dispatch:

permissions:
  contents: read

env:
  MS_TENANT_ID: ${{ secrets.MS_TENANT_ID || secrets.AZURE_AD_TENANT_ID }}
  MS_SELLER_ID: ${{ secrets.MS_SELLER_ID || secrets.SELLER_ID }}
  MS_CLIENT_ID: ${{ secrets.MS_CLIENT_ID || secrets.AZURE_AD_APPLICATION_CLIENT_ID }}
  MS_CLIENT_SECRET: ${{ secrets.MS_CLIENT_SECRET || secrets.AZURE_AD_APPLICATION_SECRET }}
  MS_STORE_APP_ID: ${{ secrets.MS_STORE_APP_ID }}

jobs:
  update-metadata:
    runs-on: windows-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Configure Microsoft Store CLI
        uses: microsoft/microsoft-store-apppublisher@v1.1

      - name: Validate Microsoft Store secrets
        shell: pwsh
        run: |
          $required = @('MS_TENANT_ID','MS_SELLER_ID','MS_CLIENT_ID','MS_CLIENT_SECRET','MS_STORE_APP_ID')
          foreach ($name in $required) {
            if (-not (Get-Item -Path "env:$name" -ErrorAction SilentlyContinue)) {
              Write-Error "$name is missing. Please set it in repository secrets."
            }
          }

      - name: Reconfigure store credentials
        shell: pwsh
        run: |
          msstore reconfigure `
            --tenantId $env:MS_TENANT_ID `
            --sellerId $env:MS_SELLER_ID `
            --clientId $env:MS_CLIENT_ID `
            --clientSecret $env:MS_CLIENT_SECRET

      - name: Check Microsoft Store submission status
        id: msstore_status
        shell: pwsh
        run: |
          $statusOutput = msstore submission status $env:MS_STORE_APP_ID 2>&1
          if ($LASTEXITCODE -ne 0) {
            Write-Warning "Failed to check submission status. Continuing: $statusOutput"
            "skip=false" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
            exit 0
          }
          if ($statusOutput -match 'Could not find a Pending Submission') {
            "skip=false" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
            exit 0
          }

          $status = ''
          $pendingMatch = [regex]::Match($statusOutput, 'Pending Submission.*?Submission Status\\s*=\\s*(\\w+)', 'Singleline')
          if ($pendingMatch.Success) {
            $status = $pendingMatch.Groups[1].Value
          } else {
            $statusMatch = [regex]::Match($statusOutput, 'Submission Status\\s*=\\s*(\\w+)')
            if ($statusMatch.Success) {
              $status = $statusMatch.Groups[1].Value
            }
          }
          $blockedStatuses = @('CommitStarted', 'PreProcessing', 'Certification', 'PendingCommit', 'InProgress')
          $blocked = $blockedStatuses -contains $status
          if ($blocked) {
            Write-Warning "Store submission in progress. Skipping metadata update. Status: $statusOutput"
            "skip=true" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
            exit 0
          }
          "skip=false" | Out-File -FilePath $env:GITHUB_OUTPUT -Append

      - name: Update store metadata
        shell: pwsh
        if: steps.msstore_status.outputs.skip != 'true'
        run: |
          "MSSTORE_SKIP_PUBLISH=false" | Out-File -FilePath $env:GITHUB_ENV -Append
          if (-not (Test-Path "metadata/metadata.json")) {
            Write-Error "metadata/metadata.json not found. Run the base metadata workflow first."
          }
          $metadataRaw = Get-Content -Raw "metadata/metadata.json"
          $metadata = $metadataRaw | ConvertFrom-Json
          foreach ($prop in @('Id','PendingApplicationId','Status','StatusDetails','FileUploadUrl','PackageDeliveryOptions','FriendlyName','Trailers','GamingOptions')) {
            if ($metadata.PSObject.Properties.Name -contains $prop) {
              $metadata.PSObject.Properties.Remove($prop)
            }
          }
          $ensureArray = {
            param($value)
            if ($null -eq $value) { return $value }
            if ($value -is [System.Array]) { return $value }
            return @($value)
          }
          if ($metadata.HardwarePreferences) {
            $metadata.HardwarePreferences = & $ensureArray $metadata.HardwarePreferences
          }
          if ($metadata.GamingOptions) {
            $metadata.GamingOptions = & $ensureArray $metadata.GamingOptions
          }
          if ($metadata.Listings) {
            foreach ($listingProp in $metadata.Listings.PSObject.Properties) {
              $listing = $listingProp.Value
              if (-not $listing) { continue }
              $baseListing = $listing.BaseListing
              if (-not $baseListing) { continue }
              foreach ($field in @('Keywords','Features','Images','RecommendedHardware','MinimumHardware')) {
                if ($baseListing.PSObject.Properties.Name -contains $field) {
                  $baseListing.$field = & $ensureArray $baseListing.$field
                }
              }
              if ($baseListing.PSObject.Properties.Name -contains 'Images') {
                $baseListing.PSObject.Properties.Remove('Images')
              }
            }
          }
          $metadataJson = $metadata | ConvertTo-Json -Depth 100 -Compress
          Write-Host "Metadata keys: $($metadata.PSObject.Properties.Name -join ', ')"
          if ($metadata.Listings) {
            Write-Host "Listings locales: $($metadata.Listings.PSObject.Properties.Name -join ', ')"
          }
          Write-Host "Metadata JSON preview (first 1500 chars):"
          Write-Host $metadataJson.Substring(0, [Math]::Min(1500, $metadataJson.Length))
          Write-Host "Metadata JSON size: $($metadataJson.Length) chars"
          $maxRetries = 3
          $delaySeconds = 30
          $success = $false
          for ($attempt = 1; $attempt -le $maxRetries; $attempt++) {
            Write-Host "Updating metadata (attempt $attempt of $maxRetries)..."
            $psi = [System.Diagnostics.ProcessStartInfo]::new()
            $psi.FileName = 'msstore'
            $psi.ArgumentList.Add('submission')
            $psi.ArgumentList.Add('updateMetadata')
            $psi.ArgumentList.Add($env:MS_STORE_APP_ID)
            $psi.ArgumentList.Add($metadataJson)
            $psi.ArgumentList.Add('--verbose')
            $psi.RedirectStandardOutput = $true
            $psi.RedirectStandardError = $true
            $psi.UseShellExecute = $false
            $process = [System.Diagnostics.Process]::Start($psi)
            $stdoutTask = $process.StandardOutput.ReadToEndAsync()
            $stderrTask = $process.StandardError.ReadToEndAsync()
            if (-not $process.WaitForExit(600000)) {
              $process.Kill()
              $updateOutput = "Metadata update timed out after 10 minutes"
              $exitCode = 124
            } else {
              $stdout = $stdoutTask.GetAwaiter().GetResult()
              $stderr = $stderrTask.GetAwaiter().GetResult()
              $updateOutput = ($stdout + $stderr).Trim()
              $exitCode = $process.ExitCode
            }
            if ($updateOutput) {
              $logPath = Join-Path $env:RUNNER_TEMP "msstore-update-metadata-$attempt.log"
              [System.IO.File]::WriteAllText($logPath, $updateOutput)
              Write-Host "msstore log saved to $logPath"
              if ($updateOutput.Length -gt 4000) {
                Write-Host $updateOutput.Substring($updateOutput.Length - 4000)
              } else {
                Write-Host $updateOutput
              }
            }
            if ($exitCode -eq 0) {
              $success = $true
              break
            }
            if ($updateOutput -match 'InvalidState' -or $updateOutput -match 'certification' -or $updateOutput -match 'Pending Submission') {
              Write-Warning "Store submission is in certification. Skipping metadata update."
              exit 0
            }
            if ($updateOutput -match '504' -or $updateOutput -match 'Gateway' -or $updateOutput -match 'timeout' -or $updateOutput -match 'timed out') {
              if ($attempt -lt $maxRetries) {
                Write-Warning "Store API timeout. Retrying in $delaySeconds seconds..."
                Start-Sleep -Seconds $delaySeconds
                $delaySeconds = [Math]::Min($delaySeconds * 2, 180)
                continue
              }
            }
            break
          }
          if (-not $success) {
            if ($updateOutput -match '504' -or $updateOutput -match 'Gateway' -or $updateOutput -match 'timeout' -or $updateOutput -match 'timed out' -or $updateOutput -match 'Error while creating submission' -or $updateOutput -match '<!DOCTYPE html') {
              Write-Warning "Partner Center timeout. Checking for pending submission..."
              $statusAfter = msstore submission status $env:MS_STORE_APP_ID 2>&1
              Write-Host $statusAfter
              if ($statusAfter -match 'Could not find a Pending Submission') {
                Write-Warning "No pending submission found; skipping Microsoft Store publish."
                "MSSTORE_SKIP_PUBLISH=true" | Out-File -FilePath $env:GITHUB_ENV -Append
                exit 0
              }
              Write-Warning "Pending submission detected; continuing to publish."
              exit 0
            }
            throw "Metadata update failed after $maxRetries attempts: $updateOutput"
          }

      - name: Publish metadata update
        shell: pwsh
        if: steps.msstore_status.outputs.skip != 'true' && env.MSSTORE_SKIP_PUBLISH != 'true'
        run: |
          $publishOutput = msstore submission publish $env:MS_STORE_APP_ID 2>&1
          if ($LASTEXITCODE -ne 0) {
            if ($publishOutput -match 'InvalidState' -or $publishOutput -match 'certification' -or $publishOutput -match 'Pending Submission') {
              Write-Warning "Store submission is in certification. Skipping metadata publish."
              exit 0
            }
            throw "Metadata publish failed: $publishOutput"
          }
