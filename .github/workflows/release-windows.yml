name: Release Windows

on:
  workflow_call:
    inputs:
      tag:
        description: 'Release tag (e.g., v0.2.3)'
        required: false
        type: string
      run_msstore:
        description: 'Run Microsoft Store publish steps even if this is not a tag push'
        required: false
        type: boolean
  workflow_dispatch:
    inputs:
      tag:
        description: 'Release tag (e.g., v0.2.3)'
        required: false
        type: string
      run_msstore:
        description: 'Run Microsoft Store publish steps even if this is not a tag push'
        required: false
        type: boolean

permissions:
  contents: write

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: false

env:
  MS_IDENTITY_NAME: "DongdaLi.Mindwtr"
  MS_PUBLISHER_ID: "CN=76AC9B15-7A1B-49FF-9342-2BE80735A1E6"
  MS_PUBLISHER_DISPLAY_NAME: "Dongda Li"

jobs:
  windows:
    runs-on: windows-latest
    name: Windows Build (EXE + MSIX)
    timeout-minutes: 90

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable

      - name: Cache Rust artifacts
        uses: Swatinem/rust-cache@v2
        with:
          workspaces: apps/desktop/src-tauri

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Setup Bun
        uses: oven-sh/setup-bun@v2
        with:
          bun-version: "1.x"

      - name: Install dependencies
        run: bun install

      - name: Install Tauri CLI
        run: cargo install tauri-cli --version "^2.0"

      - name: Resolve version
        id: version
        shell: pwsh
        run: |
          $tag = "${{ inputs.tag }}"
          if (-not $tag) { $tag = "${{ github.event.inputs.tag }}" }
          if (-not $tag) { $tag = "${{ github.ref_name }}" }
          $version = $tag -replace '^v',''
          if (-not $version) { $version = "0.0.0" }
          $msixVersion = ($version.Split('.') + @('0','0','0','0'))[0..3] -join '.'
          echo "version=$version" >> $env:GITHUB_OUTPUT
          echo "msix_version=$msixVersion" >> $env:GITHUB_OUTPUT

      - name: Build Tauri app
        run: |
          cd apps/desktop
          cargo tauri build
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Ensure MakeAppx is available
        shell: pwsh
        run: |
          $makeappx = Get-ChildItem -Path "C:\Program Files (x86)\Windows Kits" -Recurse -Filter "makeappx.exe" -ErrorAction SilentlyContinue |
            Where-Object { $_.FullName -match "\\x64\\makeappx.exe$" } |
            Select-Object -First 1 -ExpandProperty FullName
          if ($makeappx) {
            Write-Host "Found makeappx at $makeappx"
            exit 0
          }
          if (Get-Command winget -ErrorAction SilentlyContinue) {
            winget install --id Microsoft.WindowsSDK.10.0.22621 --silent --accept-package-agreements --accept-source-agreements
            exit 0
          }
          Write-Error "makeappx.exe not found and winget is unavailable."

      - name: Create MSIX layout
        shell: pwsh
        run: |
          $buildDir = "apps/desktop/src-tauri/target/release"
          $outDir = "msix-staging"
          $iconDir = "apps/desktop/src-tauri/icons"
          New-Item -ItemType Directory -Force -Path $outDir | Out-Null
          New-Item -ItemType Directory -Force -Path "$outDir\Assets" | Out-Null
          Copy-Item "$buildDir/mindwtr.exe" -Destination "$outDir/mindwtr.exe"
          if (Test-Path "$buildDir/WebView2Loader.dll") {
            Copy-Item "$buildDir/WebView2Loader.dll" -Destination "$outDir"
          }
          Copy-Item "$iconDir/Square44x44Logo.png" "$outDir\Assets\StoreLogo.png"
          Copy-Item "$iconDir/Square150x150Logo.png" "$outDir\Assets\Square150x150Logo.png"
          Copy-Item "$iconDir/Square44x44Logo.png" "$outDir\Assets\Square44x44Logo.png"

      - name: Generate AppxManifest.xml
        shell: pwsh
        run: |
          $manifest = @"
          <?xml version="1.0" encoding="utf-8"?>
          <Package xmlns="http://schemas.microsoft.com/appx/manifest/foundation/windows10" 
                   xmlns:uap="http://schemas.microsoft.com/appx/manifest/uap/windows10" 
                   xmlns:rescap="http://schemas.microsoft.com/appx/manifest/foundation/windows10/restrictedcapabilities">
            <Identity Name="$env:MS_IDENTITY_NAME" 
                      Publisher="$env:MS_PUBLISHER_ID" 
                      Version="${{ steps.version.outputs.msix_version }}" />
            <Properties>
              <DisplayName>Mindwtr</DisplayName>
              <PublisherDisplayName>$env:MS_PUBLISHER_DISPLAY_NAME</PublisherDisplayName>
              <Logo>Assets\StoreLogo.png</Logo>
            </Properties>
            <Dependencies>
              <TargetDeviceFamily Name="Windows.Desktop" MinVersion="10.0.17763.0" MaxVersionTested="10.0.19041.0" />
            </Dependencies>
            <Resources>
              <Resource Language="en-us" />
            </Resources>
            <Applications>
              <Application Id="App" Executable="mindwtr.exe" EntryPoint="Windows.FullTrustApplication">
                <uap:VisualElements DisplayName="Mindwtr" 
                                    Description="Local-first GTD application" 
                                    BackgroundColor="transparent" 
                                    Square150x150Logo="Assets\Square150x150Logo.png" 
                                    Square44x44Logo="Assets\Square44x44Logo.png">
                </uap:VisualElements>
              </Application>
            </Applications>
            <Capabilities>
              <rescap:Capability Name="runFullTrust" />
            </Capabilities>
          </Package>
          "@
          $manifest | Out-File -FilePath "msix-staging\AppxManifest.xml" -Encoding UTF8

      - name: Build MSIX package
        shell: pwsh
        run: |
          $msixPath = "mindwtr_${{ steps.version.outputs.version }}_x64.msix"
          $makeappx = Get-ChildItem -Path "C:\Program Files (x86)\Windows Kits" -Recurse -Filter "makeappx.exe" -ErrorAction SilentlyContinue |
            Where-Object { $_.FullName -match "\\x64\\makeappx.exe$" } |
            Select-Object -First 1 -ExpandProperty FullName
          if (-not $makeappx) {
            throw "makeappx.exe not found for x64"
          }
          & $makeappx pack /d msix-staging /p $msixPath /o

      - name: Validate Microsoft Store secrets
        if: startsWith(github.ref, 'refs/tags/') || inputs.run_msstore == 'true' || inputs.run_msstore == true
        shell: pwsh
        env:
          MS_TENANT_ID: ${{ secrets.MS_TENANT_ID }}
          MS_CLIENT_ID: ${{ secrets.MS_CLIENT_ID }}
          MS_CLIENT_SECRET: ${{ secrets.MS_CLIENT_SECRET }}
          MS_STORE_APP_ID: ${{ secrets.MS_STORE_APP_ID || '9N0V5B0B6FRX' }}
        run: |
          $required = @('MS_TENANT_ID','MS_CLIENT_ID','MS_CLIENT_SECRET','MS_STORE_APP_ID')
          foreach ($name in $required) {
            if (-not (Get-Item -Path "env:$name" -ErrorAction SilentlyContinue)) {
              Write-Error "$name is missing. Please set it in repository secrets."
            }
          }

      - name: Check Microsoft Store submission status
        id: msstore_status
        if: startsWith(github.ref, 'refs/tags/') || inputs.run_msstore == 'true' || inputs.run_msstore == true
        shell: pwsh
        env:
          MS_TENANT_ID: ${{ secrets.MS_TENANT_ID }}
          MS_CLIENT_ID: ${{ secrets.MS_CLIENT_ID }}
          MS_CLIENT_SECRET: ${{ secrets.MS_CLIENT_SECRET }}
          MS_STORE_APP_ID: ${{ secrets.MS_STORE_APP_ID || '9N0V5B0B6FRX' }}
        run: |
          $tokenBody = @{
            grant_type    = 'client_credentials'
            resource      = 'https://manage.devcenter.microsoft.com'
            client_id     = $env:MS_CLIENT_ID
            client_secret = $env:MS_CLIENT_SECRET
          }
          try {
            $tokenResponse = Invoke-RestMethod -Method Post `
              -Uri "https://login.microsoftonline.com/$($env:MS_TENANT_ID)/oauth2/token" `
              -ContentType 'application/x-www-form-urlencoded' `
              -Body $tokenBody
          } catch {
            Write-Warning "Failed to obtain token for status check. Continuing: $_"
            "skip=false" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
            exit 0
          }
          $headers = @{ 'Authorization' = "Bearer $($tokenResponse.access_token)" }

          try {
            $appsResponse = Invoke-RestMethod -Method Get `
              -Uri 'https://manage.devcenter.microsoft.com/v1.0/my/applications' `
              -Headers $headers
          } catch {
            Write-Warning "Failed to list applications. Continuing: $_"
            "skip=false" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
            exit 0
          }

          $app = $appsResponse.value | Where-Object {
            $_.id -eq $env:MS_STORE_APP_ID -or
            ($_.applicationId -and $_.applicationId -eq $env:MS_STORE_APP_ID) -or
            ($_ | ConvertTo-Json -Depth 5 | Select-String -Pattern $env:MS_STORE_APP_ID -Quiet)
          } | Select-Object -First 1

          if (-not $app) {
            Write-Warning "Could not find app for status check. Continuing."
            "skip=false" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
            exit 0
          }

          $pendingSub = $null
          if ($app.PSObject.Properties.Name -contains 'pendingApplicationSubmission') {
            $pendingSub = $app.pendingApplicationSubmission
          }
          if ($pendingSub) {
            $pendingId = $pendingSub.id
            $applicationId = $app.id
            try {
              $statusResponse = Invoke-RestMethod -Method Get `
                -Uri "https://manage.devcenter.microsoft.com/v1.0/my/applications/$applicationId/submissions/$pendingId/status" `
                -Headers $headers
              $status = $statusResponse.status
              $blockedStatuses = @('CommitStarted', 'PreProcessing', 'Certification', 'Publishing', 'Release')
              if ($blockedStatuses -contains $status) {
                Write-Warning "Existing submission is in '$status' state. Skipping Store update."
                "skip=true" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
                exit 0
              }
            } catch {
              Write-Warning "Failed to check pending submission status: $_"
            }
          }
          "skip=false" | Out-File -FilePath $env:GITHUB_OUTPUT -Append

      - name: Publish to Microsoft Store (metadata + package)
        if: (startsWith(github.ref, 'refs/tags/') || inputs.run_msstore == 'true' || inputs.run_msstore == true) && steps.msstore_status.outputs.skip != 'true' && env.MSSTORE_SKIP_PUBLISH != 'true'
        shell: pwsh
        env:
          MS_TENANT_ID: ${{ secrets.MS_TENANT_ID }}
          MS_CLIENT_ID: ${{ secrets.MS_CLIENT_ID }}
          MS_CLIENT_SECRET: ${{ secrets.MS_CLIENT_SECRET }}
          MS_STORE_APP_ID: ${{ secrets.MS_STORE_APP_ID || '9N0V5B0B6FRX' }}
        run: |
          Set-StrictMode -Version Latest
          $ErrorActionPreference = 'Stop'

          $msixPath = (Resolve-Path "mindwtr_${{ steps.version.outputs.version }}_x64.msix").Path
          $msixFileName = [System.IO.Path]::GetFileName($msixPath)

          $isStoreBusy = {
            param([string]$text)
            if ([string]::IsNullOrWhiteSpace($text)) { return $false }
            return $text -match '(?i)(InvalidState|CommitStarted|PreProcessing|Certification|InCertification|PendingCommit|InProgress|Pending[\s_-]*Submission|Another\s+submission|already\s+.*submission)'
          }

          $tokenBody = @{
            grant_type    = 'client_credentials'
            resource      = 'https://manage.devcenter.microsoft.com'
            client_id     = $env:MS_CLIENT_ID
            client_secret = $env:MS_CLIENT_SECRET
          }
          Write-Host "Obtaining Partner Center access token..."
          $tokenResponse = Invoke-RestMethod -Method Post `
            -Uri "https://login.microsoftonline.com/$($env:MS_TENANT_ID)/oauth2/token" `
            -ContentType 'application/x-www-form-urlencoded' `
            -Body $tokenBody
          $accessToken = $tokenResponse.access_token
          if (-not $accessToken) {
            throw "Failed to obtain Partner Center access token."
          }
          $headers = @{
            'Authorization' = "Bearer $accessToken"
            'Content-Type'  = 'application/json'
          }

          Write-Host "Looking up application..."
          $appsResponse = Invoke-RestMethod -Method Get `
            -Uri 'https://manage.devcenter.microsoft.com/v1.0/my/applications' `
            -Headers $headers
          $app = $appsResponse.value | Where-Object {
            $_.id -eq $env:MS_STORE_APP_ID -or
            ($_.applicationId -and $_.applicationId -eq $env:MS_STORE_APP_ID) -or
            ($_ | ConvertTo-Json -Depth 5 | Select-String -Pattern $env:MS_STORE_APP_ID -Quiet)
          } | Select-Object -First 1
          if (-not $app) {
            Write-Host "Available apps:"
            $appsResponse.value | ForEach-Object { Write-Host "  ID=$($_.id)  primaryName=$($_.primaryName)" }
            throw "Could not find app matching MS_STORE_APP_ID='$($env:MS_STORE_APP_ID)'."
          }
          $applicationId = $app.id
          Write-Host "Found application: $($app.primaryName) (ID: $applicationId)"

          $pendingSub = $null
          if ($app.PSObject.Properties.Name -contains 'pendingApplicationSubmission') {
            $pendingSub = $app.pendingApplicationSubmission
          }
          if ($pendingSub) {
            $pendingId = $pendingSub.id
            Write-Host "Deleting existing pending submission $pendingId..."
            try {
              Invoke-RestMethod -Method Delete `
                -Uri "https://manage.devcenter.microsoft.com/v1.0/my/applications/$applicationId/submissions/$pendingId" `
                -Headers $headers
              Write-Host "Deleted pending submission."
            } catch {
              $errText = $_.Exception.Message
              if (& $isStoreBusy $errText) {
                Write-Warning "Existing submission is in certification; cannot delete. Skipping publish."
                exit 0
              }
              throw
            }
          }

          Write-Host "Creating new submission..."
          $submission = Invoke-RestMethod -Method Post `
            -Uri "https://manage.devcenter.microsoft.com/v1.0/my/applications/$applicationId/submissions" `
            -Headers $headers
          $submissionId = $submission.id
          $fileUploadUrl = $submission.fileUploadUrl
          Write-Host "Created submission $submissionId"

          $packages = [System.Collections.ArrayList]::new()
          if ($submission.applicationPackages) {
            foreach ($pkg in $submission.applicationPackages) {
              $pkg.fileStatus = 'PendingDelete'
              [void]$packages.Add($pkg)
            }
          }
          [void]$packages.Add(@{
            fileName              = $msixFileName
            fileStatus            = 'PendingUpload'
            minimumDirectXVersion = 'None'
            minimumSystemRam      = 'None'
          })
          $submission.applicationPackages = $packages.ToArray()

          if (Test-Path "metadata/metadata.json") {
            Write-Host "Applying metadata from metadata/metadata.json..."
            $metadata = Get-Content -Raw "metadata/metadata.json" | ConvertFrom-Json

            function Normalize-StoreListingText {
              param([string]$Text)
              if ([string]::IsNullOrWhiteSpace($Text)) {
                return $Text
              }

              $normalized = $Text -replace "`r`n?", "`n"

              # Fix hard wraps that split short words (e.g., Lo\ncal-First) and CJK punctuation/characters.
              $normalized = [System.Text.RegularExpressions.Regex]::Replace(
                $normalized,
                '([A-Za-zÀ-ÖØ-öø-ÿ]{1,2})\n([a-zà-öø-ÿ])',
                '$1$2'
              )
              $normalized = [System.Text.RegularExpressions.Regex]::Replace(
                $normalized,
                '([\p{IsCJKUnifiedIdeographs}])\n([，。！？、；：）】》」』\p{IsCJKUnifiedIdeographs}])',
                '$1$2'
              )

              # Convert single line breaks to spaces, while preserving paragraph breaks and bullet lines.
              $normalized = [System.Text.RegularExpressions.Regex]::Replace(
                $normalized,
                '(?<!\n)\n(?!\n|[•*\-]|\d+[.)]\s)',
                ' '
              )

              $normalized = [System.Text.RegularExpressions.Regex]::Replace($normalized, ' {2,}', ' ')
              $normalized = [System.Text.RegularExpressions.Regex]::Replace($normalized, '\s+([,.;:!?])', '$1')
              $normalized = [System.Text.RegularExpressions.Regex]::Replace($normalized, '\s+([，。！？、；：）】》」』])', '$1')
              return $normalized.Trim()
            }

            if ($metadata.PSObject.Properties.Name -contains 'Listings' -and $metadata.Listings) {
              foreach ($listingProp in $metadata.Listings.PSObject.Properties) {
                if (-not $listingProp.Value) { continue }
                if (-not ($listingProp.Value.PSObject.Properties.Name -contains 'BaseListing')) { continue }
                $baseListing = $listingProp.Value.BaseListing
                if (-not $baseListing) { continue }
                if ($baseListing.PSObject.Properties.Name -contains 'Description') {
                  $baseListing.Description = Normalize-StoreListingText -Text ([string]$baseListing.Description)
                }
              }
            }

            $fieldMap = @{
              listings = 'Listings'
              applicationCategory = 'ApplicationCategory'
              pricing = 'Pricing'
              visibility = 'Visibility'
              targetPublishMode = 'TargetPublishMode'
              targetPublishDate = 'TargetPublishDate'
              hardwarePreferences = 'HardwarePreferences'
              hasExternalInAppProducts = 'HasExternalInAppProducts'
              meetAccessibilityGuidelines = 'MeetAccessibilityGuidelines'
              notesForCertification = 'NotesForCertification'
              allowMicrosoftDecideAppAvailabilityToFutureDeviceFamilies = 'AllowMicrosoftDecideAppAvailabilityToFutureDeviceFamilies'
              allowTargetFutureDeviceFamilies = 'AllowTargetFutureDeviceFamilies'
              automaticBackupEnabled = 'AutomaticBackupEnabled'
              canInstallOnRemovableMedia = 'CanInstallOnRemovableMedia'
              isGameDvrEnabled = 'IsGameDvrEnabled'
              enterpriseLicensing = 'EnterpriseLicensing'
            }
            foreach ($target in $fieldMap.Keys) {
              $source = $fieldMap[$target]
              if ($metadata.PSObject.Properties.Name -contains $source) {
                $submission.$target = $metadata.$source
              }
            }
          } else {
            Write-Warning "metadata/metadata.json not found; submitting cloned metadata from last published version."
          }

          foreach ($prop in @('id', 'status', 'statusDetails', 'fileUploadUrl', 'friendlyName', 'pendingApplicationId')) {
            if ($submission.PSObject.Properties.Name -contains $prop) {
              $submission.PSObject.Properties.Remove($prop)
            }
          }
          $submissionJson = $submission | ConvertTo-Json -Depth 100 -Compress

          Write-Host "Updating submission data (metadata + package references)..."
          Invoke-RestMethod -Method Put `
            -Uri "https://manage.devcenter.microsoft.com/v1.0/my/applications/$applicationId/submissions/$submissionId" `
            -Headers $headers `
            -Body ([System.Text.Encoding]::UTF8.GetBytes($submissionJson)) `
            -ContentType 'application/json; charset=utf-8'

          Write-Host "Creating ZIP archive for upload..."
          $zipPath = "$env:RUNNER_TEMP/submission-package.zip"
          if (Test-Path $zipPath) { Remove-Item $zipPath -Force }
          Compress-Archive -Path $msixPath -DestinationPath $zipPath -Force
          $zipBytes = [System.IO.File]::ReadAllBytes($zipPath)

          Write-Host "Uploading package payload..."
          Invoke-RestMethod -Method Put `
            -Uri $fileUploadUrl `
            -Headers @{ 'x-ms-blob-type' = 'BlockBlob' } `
            -Body $zipBytes `
            -ContentType 'application/octet-stream'

          Write-Host "Committing submission..."
          Invoke-RestMethod -Method Post `
            -Uri "https://manage.devcenter.microsoft.com/v1.0/my/applications/$applicationId/submissions/$submissionId/commit" `
            -Headers @{ 'Authorization' = "Bearer $accessToken"; 'Content-Type' = 'application/json' } `
            -Body '{}'

          Write-Host "Polling submission status..."
          $deadline = (Get-Date).AddMinutes(30)
          while ((Get-Date) -lt $deadline) {
            Start-Sleep -Seconds 30
            try {
              $statusResponse = Invoke-RestMethod -Method Get `
                -Uri "https://manage.devcenter.microsoft.com/v1.0/my/applications/$applicationId/submissions/$submissionId/status" `
                -Headers @{ 'Authorization' = "Bearer $accessToken" }
            } catch {
              Write-Warning "Status poll failed, refreshing token: $_"
              $tokenResponse = Invoke-RestMethod -Method Post `
                -Uri "https://login.microsoftonline.com/$($env:MS_TENANT_ID)/oauth2/token" `
                -ContentType 'application/x-www-form-urlencoded' `
                -Body $tokenBody
              $accessToken = $tokenResponse.access_token
              continue
            }
            $currentStatus = $statusResponse.status
            Write-Host "  Status: $currentStatus"
            if ($currentStatus -eq 'CommitFailed') {
              $details = $statusResponse.statusDetails | ConvertTo-Json -Depth 5
              throw "Submission commit failed. Details: $details"
            }
            if ($currentStatus -in @('PreProcessing', 'Certification', 'Publishing', 'Published', 'Release')) {
              break
            }
          }
          Write-Host "Microsoft Store publish completed."

      - name: Collect Windows artifacts
        shell: pwsh
        run: |
          New-Item -ItemType Directory -Force -Path release-artifacts | Out-Null
          Get-ChildItem "apps/desktop/src-tauri/target/release/bundle/nsis/*.exe" -ErrorAction SilentlyContinue | ForEach-Object {
            $lower = $_.Name.ToLower()
            Copy-Item $_.FullName "release-artifacts/$lower"
          }
          Get-ChildItem "apps/desktop/src-tauri/target/release/bundle/msi/*.msi" -ErrorAction SilentlyContinue | ForEach-Object {
            $lower = $_.Name.ToLower()
            Copy-Item $_.FullName "release-artifacts/$lower"
          }
          Get-ChildItem "mindwtr_*.msix" -ErrorAction SilentlyContinue | ForEach-Object {
            Copy-Item $_.FullName "release-artifacts/$($_.Name.ToLower())"
          }
          Get-ChildItem release-artifacts

      - name: Upload Windows artifacts
        uses: actions/upload-artifact@v4
        with:
          name: release-windows
          path: release-artifacts/*
          if-no-files-found: warn
