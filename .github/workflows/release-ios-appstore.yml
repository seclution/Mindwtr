name: Release iOS App Store

on:
  workflow_dispatch:
    inputs:
      upload:
        description: Upload to App Store Connect
        required: false
        default: 'true'

permissions:
  contents: read

jobs:
  ios-appstore:
    runs-on: macos-26
    timeout-minutes: 90
    env:
      EXPECTED_TEAM_ID: 5X9JC5PL7T
      EXPECTED_BUNDLE_ID: tech.dongdongbh.mindwtr
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Select Xcode
        run: |
          set -euo pipefail
          XCODE_26_PATH="$(ls -d /Applications/Xcode_26*.app 2>/dev/null | sort -V | tail -n 1 || true)"
          if [ -n "${XCODE_26_PATH:-}" ]; then
            sudo xcode-select -s "$XCODE_26_PATH"
          fi
          xcodebuild -version
          if ! xcodebuild -showsdks | grep -q "iphoneos26"; then
            echo "::error::iOS 26 SDK not found on runner. Current SDKs:"
            xcodebuild -showsdks
            exit 1
          fi

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Setup Bun
        uses: oven-sh/setup-bun@v2
        with:
          bun-version: latest

      - name: Install dependencies
        run: bun install

      - name: Validate required secrets
        env:
          IOS_DISTRIBUTION_CERT: ${{ secrets.IOS_DISTRIBUTION_CERT }}
          IOS_DISTRIBUTION_CERT_PWD: ${{ secrets.IOS_DISTRIBUTION_CERT_PWD }}
          IOS_PROVISIONING_PROFILE: ${{ secrets.IOS_PROVISIONING_PROFILE }}
          IOS_ASC_KEY_ID: ${{ secrets.IOS_ASC_KEY_ID }}
          IOS_ASC_ISSUER_ID: ${{ secrets.IOS_ASC_ISSUER_ID }}
          IOS_ASC_PRIVATE_KEY: ${{ secrets.IOS_ASC_PRIVATE_KEY }}
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_PASSWORD: ${{ secrets.APPLE_PASSWORD }}
          UPLOAD_TO_APP_STORE: ${{ github.event.inputs.upload || 'true' }}
        run: |
          set -euo pipefail
          missing=0
          for key in IOS_DISTRIBUTION_CERT IOS_DISTRIBUTION_CERT_PWD IOS_PROVISIONING_PROFILE; do
            if [ -z "${!key:-}" ]; then
              echo "::error::Missing required secret: $key"
              missing=1
            fi
          done
          for key in IOS_ASC_KEY_ID IOS_ASC_ISSUER_ID IOS_ASC_PRIVATE_KEY; do
            if [ -z "${!key:-}" ]; then
              echo "::error::Missing required App Store Connect API secret: $key"
              missing=1
            fi
          done
          if [ "${UPLOAD_TO_APP_STORE}" = "true" ]; then
            for key in APPLE_ID APPLE_PASSWORD; do
              if [ -z "${!key:-}" ]; then
                echo "::error::Missing required secret for upload: $key"
                missing=1
              fi
            done
          fi
          if [ "$missing" -ne 0 ]; then
            exit 1
          fi

      - name: Resolve iOS version metadata
        env:
          IOS_ASC_KEY_ID: ${{ secrets.IOS_ASC_KEY_ID }}
          IOS_ASC_ISSUER_ID: ${{ secrets.IOS_ASC_ISSUER_ID }}
          IOS_ASC_PRIVATE_KEY: ${{ secrets.IOS_ASC_PRIVATE_KEY }}
        run: |
          set -euo pipefail
          APP_VERSION="$(jq -r '.expo.version // empty' apps/mobile/app.json)"
          APP_BUILD_NUMBER_BASE="$(jq -r '.expo.ios.buildNumber // "0"' apps/mobile/app.json)"
          if [ -z "${APP_VERSION}" ]; then
            echo "::error::Missing expo.version in apps/mobile/app.json"
            exit 1
          fi

          REMOTE_MAX_BUILD=0
          REMOTE_LOOKUP_STATUS="skipped"
          if [ -n "${IOS_ASC_KEY_ID:-}" ] && [ -n "${IOS_ASC_ISSUER_ID:-}" ] && [ -n "${IOS_ASC_PRIVATE_KEY:-}" ]; then
            ASC_KEY_ID="$(printf '%s' "$IOS_ASC_KEY_ID" | tr -d '\r\n\t ')"
            ASC_ISSUER_ID="$(printf '%s' "$IOS_ASC_ISSUER_ID" | tr -d '\r\n\t ')"
            if ! printf '%s' "$ASC_KEY_ID" | grep -Eq '^[A-Z0-9]{10}$'; then
              echo "::warning::IOS_ASC_KEY_ID format looks invalid after trimming (expected 10 chars, e.g. ABCD123456)."
            fi
            if ! printf '%s' "$ASC_ISSUER_ID" | grep -Eq '^[0-9a-fA-F-]{36}$'; then
              echo "::warning::IOS_ASC_ISSUER_ID format looks invalid after trimming (expected UUID)."
            fi
            KEY_PATH="$RUNNER_TEMP/ios-asc-key.p8"
            if printf '%s' "$IOS_ASC_PRIVATE_KEY" | grep -q "BEGIN PRIVATE KEY"; then
              # Support both multiline PEM and single-line PEM with '\n' escapes
              printf '%b' "$IOS_ASC_PRIVATE_KEY" | tr -d '\r' > "$KEY_PATH"
            else
              if ! printf '%s' "$IOS_ASC_PRIVATE_KEY" | tr -d '\r' | base64 --decode > "$KEY_PATH" 2>/dev/null; then
                printf '%s' "$IOS_ASC_PRIVATE_KEY" | tr -d '\r' | base64 -D > "$KEY_PATH"
              fi
            fi

            if ! openssl pkey -in "$KEY_PATH" -noout >/dev/null 2>&1; then
              echo "::warning::IOS_ASC_PRIVATE_KEY is not a valid .p8 key; skipping remote max build lookup."
              REMOTE_LOOKUP_STATUS="invalid_key"
            else
              api_get() {
                local out_file="$1"
                shift
                local tmp_body="$RUNNER_TEMP/asc-api-$(date +%s)-$RANDOM.json"
                local http_code
                http_code="$(curl -sS -w '%{http_code}' -o "$tmp_body" "$@" || true)"
                if [ "${http_code}" -ge 200 ] && [ "${http_code}" -lt 300 ]; then
                  mv "$tmp_body" "$out_file"
                  return 0
                fi
                local preview
                preview="$(tr '\n' ' ' < "$tmp_body" | head -c 240)"
                rm -f "$tmp_body"
                echo "::warning::App Store Connect API request failed (HTTP ${http_code}): ${preview}"
                return 1
              }

              if ! ASC_TOKEN="$(
                node -e 'const fs = require("fs"); const crypto = require("crypto"); const keyId = process.argv[1]; const issuerId = process.argv[2]; const keyPath = process.argv[3]; const now = Math.floor(Date.now() / 1000); const exp = now + 1200; const encodeJson = (obj) => Buffer.from(JSON.stringify(obj)).toString("base64url"); const header = encodeJson({ alg: "ES256", kid: keyId, typ: "JWT" }); const payload = encodeJson({ iss: issuerId, iat: now, exp, aud: "appstoreconnect-v1" }); const unsignedToken = header + "." + payload; const privateKey = fs.readFileSync(keyPath, "utf8"); const signature = crypto.sign("sha256", Buffer.from(unsignedToken), { key: privateKey, dsaEncoding: "ieee-p1363" }); process.stdout.write(unsignedToken + "." + signature.toString("base64url"));' "$ASC_KEY_ID" "$ASC_ISSUER_ID" "$KEY_PATH"
              )"; then
                echo "::warning::Failed to generate App Store Connect JWT from IOS_ASC_* secrets."
                REMOTE_LOOKUP_STATUS="invalid_jwt"
              fi

              APP_LOOKUP_JSON_FILE="$RUNNER_TEMP/asc-app-lookup.json"
              if [ "${REMOTE_LOOKUP_STATUS}" != "invalid_jwt" ]; then
                if api_get "$APP_LOOKUP_JSON_FILE" -G \
                  -H "Authorization: Bearer ${ASC_TOKEN}" \
                  --data-urlencode "filter[bundleId]=${EXPECTED_BUNDLE_ID}" \
                  --data-urlencode "limit=1" \
                  "https://api.appstoreconnect.apple.com/v1/apps"; then
                  APPSTORE_APP_ID="$(jq -r '.data[0].id // empty' "$APP_LOOKUP_JSON_FILE")"
                  if [ -n "${APPSTORE_APP_ID}" ]; then
                    BUILDS_JSON_FILE="$RUNNER_TEMP/asc-builds-page.json"
                    if api_get "$BUILDS_JSON_FILE" -G \
                      -H "Authorization: Bearer ${ASC_TOKEN}" \
                      --data-urlencode "filter[app]=${APPSTORE_APP_ID}" \
                      --data-urlencode "limit=200" \
                      "https://api.appstoreconnect.apple.com/v1/builds"; then
                      while : ; do
                        PAGE_MAX="$(jq -r '[.data[]?.attributes.version | select(type=="string") | select(test("^[0-9]+$")) | tonumber] | max // 0' "$BUILDS_JSON_FILE")"
                        if [ "${PAGE_MAX}" -gt "${REMOTE_MAX_BUILD}" ]; then
                          REMOTE_MAX_BUILD="${PAGE_MAX}"
                        fi
                        NEXT_URL="$(jq -r '.links.next // empty' "$BUILDS_JSON_FILE")"
                        if [ -z "${NEXT_URL}" ]; then
                          REMOTE_LOOKUP_STATUS="ok"
                          break
                        fi
                        if ! api_get "$BUILDS_JSON_FILE" -g -H "Authorization: Bearer ${ASC_TOKEN}" "$NEXT_URL"; then
                          REMOTE_LOOKUP_STATUS="api_error"
                          break
                        fi
                      done
                    else
                      REMOTE_LOOKUP_STATUS="api_error"
                    fi
                  else
                    echo "::warning::App Store Connect app lookup returned no app for bundle id ${EXPECTED_BUNDLE_ID}."
                    REMOTE_LOOKUP_STATUS="no_app"
                  fi
                else
                  REMOTE_LOOKUP_STATUS="api_error"
                fi
              fi
            fi
          else
            echo "::warning::Remote max build lookup skipped. Set IOS_ASC_KEY_ID / IOS_ASC_ISSUER_ID / IOS_ASC_PRIVATE_KEY secrets."
          fi

          LOCAL_MIN_BUILD=1
          if [[ "${APP_BUILD_NUMBER_BASE}" =~ ^[0-9]+$ ]]; then
            LOCAL_MIN_BUILD="$((APP_BUILD_NUMBER_BASE + 1))"
          fi
          REMOTE_MIN_BUILD="$((REMOTE_MAX_BUILD + 1))"
          FINAL_BUILD_NUMBER="${LOCAL_MIN_BUILD}"
          if [ "${REMOTE_MIN_BUILD}" -gt "${FINAL_BUILD_NUMBER}" ]; then
            FINAL_BUILD_NUMBER="${REMOTE_MIN_BUILD}"
          fi

          echo "APP_VERSION=${APP_VERSION}" >> "$GITHUB_ENV"
          echo "APP_BUILD_NUMBER=${FINAL_BUILD_NUMBER}" >> "$GITHUB_ENV"
          echo "Resolved iOS build number: ${FINAL_BUILD_NUMBER} (remote max: ${REMOTE_MAX_BUILD}, remote lookup: ${REMOTE_LOOKUP_STATUS}, local base: ${APP_BUILD_NUMBER_BASE})"

      - name: Import iOS distribution certificate
        env:
          IOS_DISTRIBUTION_CERT: ${{ secrets.IOS_DISTRIBUTION_CERT }}
          IOS_DISTRIBUTION_CERT_PWD: ${{ secrets.IOS_DISTRIBUTION_CERT_PWD }}
          IOS_SIGNING_IDENTITY: ${{ secrets.IOS_SIGNING_IDENTITY }}
        run: |
          set -euo pipefail

          decode_base64() {
            local input="$1"
            local output="$2"
            if ! printf '%s' "$input" | tr -d '\r' | base64 --decode > "$output" 2>/dev/null; then
              printf '%s' "$input" | tr -d '\r' | base64 -D > "$output"
            fi
          }

          KEYCHAIN_PATH="$RUNNER_TEMP/mindwtr-ios.keychain-db"
          KEYCHAIN_PASSWORD="$(openssl rand -base64 24)"
          CERT_PATH="$RUNNER_TEMP/ios-distribution.p12"

          decode_base64 "$IOS_DISTRIBUTION_CERT" "$CERT_PATH"
          if ! openssl pkcs12 -in "$CERT_PATH" -passin "pass:${IOS_DISTRIBUTION_CERT_PWD}" -nokeys -clcerts >/dev/null 2>&1; then
            echo "::error::Unable to open IOS_DISTRIBUTION_CERT with IOS_DISTRIBUTION_CERT_PWD."
            exit 1
          fi

          security create-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          security set-keychain-settings -lut 21600 "$KEYCHAIN_PATH"
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          LOGIN_KEYCHAIN="$HOME/Library/Keychains/login.keychain-db"
          if [ -f "$LOGIN_KEYCHAIN" ]; then
            security list-keychains -d user -s "$KEYCHAIN_PATH" "$LOGIN_KEYCHAIN" "/Library/Keychains/System.keychain"
          else
            security list-keychains -d user -s "$KEYCHAIN_PATH" "/Library/Keychains/System.keychain"
          fi
          security default-keychain -s "$KEYCHAIN_PATH"

          security import "$CERT_PATH" -k "$KEYCHAIN_PATH" -P "$IOS_DISTRIBUTION_CERT_PWD" -A -T /usr/bin/codesign -T /usr/bin/security -T /usr/bin/xcodebuild
          security set-key-partition-list -S apple-tool:,apple:,codesign:,xcodebuild:,security: -s -k "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"

          RESOLVED_IDENTITY="${IOS_SIGNING_IDENTITY:-}"
          if [ -z "${RESOLVED_IDENTITY}" ]; then
            RESOLVED_IDENTITY="$(security find-identity -v -p codesigning "$KEYCHAIN_PATH" | sed -n 's/.*"\(Apple Distribution:.*\)".*/\1/p' | head -n 1)"
          fi
          if [ -z "${RESOLVED_IDENTITY}" ]; then
            echo "::error::Could not resolve Apple Distribution identity from imported certificate."
            security find-identity -v -p codesigning "$KEYCHAIN_PATH" || true
            exit 1
          fi

          echo "KEYCHAIN_PATH=$KEYCHAIN_PATH" >> "$GITHUB_ENV"
          echo "KEYCHAIN_PASSWORD=$KEYCHAIN_PASSWORD" >> "$GITHUB_ENV"
          echo "IOS_SIGNING_IDENTITY=$RESOLVED_IDENTITY" >> "$GITHUB_ENV"
          security find-identity -v -p codesigning "$KEYCHAIN_PATH" || true

      - name: Install and validate provisioning profile
        env:
          IOS_PROVISIONING_PROFILE: ${{ secrets.IOS_PROVISIONING_PROFILE }}
        run: |
          set -euo pipefail

          decode_base64() {
            local input="$1"
            local output="$2"
            if ! printf '%s' "$input" | tr -d '\r' | base64 --decode > "$output" 2>/dev/null; then
              printf '%s' "$input" | tr -d '\r' | base64 -D > "$output"
            fi
          }

          PROFILE_PATH="$RUNNER_TEMP/mindwtr-ios.mobileprovision"
          PROFILE_PLIST="$RUNNER_TEMP/mindwtr-ios-profile.plist"
          decode_base64 "$IOS_PROVISIONING_PROFILE" "$PROFILE_PATH"
          security cms -D -i "$PROFILE_PATH" > "$PROFILE_PLIST"

          PROFILE_UUID="$(/usr/libexec/PlistBuddy -c 'Print UUID' "$PROFILE_PLIST")"
          PROFILE_NAME="$(/usr/libexec/PlistBuddy -c 'Print Name' "$PROFILE_PLIST")"
          PROFILE_TEAM_ID="$(/usr/libexec/PlistBuddy -c 'Print TeamIdentifier:0' "$PROFILE_PLIST")"
          PROFILE_APP_ID="$(/usr/libexec/PlistBuddy -c 'Print Entitlements:application-identifier' "$PROFILE_PLIST")"

          if [ "$PROFILE_TEAM_ID" != "$EXPECTED_TEAM_ID" ]; then
            echo "::error::Profile TeamIdentifier ($PROFILE_TEAM_ID) does not match expected team ($EXPECTED_TEAM_ID)."
            exit 1
          fi

          EXPECTED_APP_ID="${EXPECTED_TEAM_ID}.${EXPECTED_BUNDLE_ID}"
          WILDCARD_APP_ID="${EXPECTED_TEAM_ID}.*"
          if [ "$PROFILE_APP_ID" != "$EXPECTED_APP_ID" ] && [ "$PROFILE_APP_ID" != "$WILDCARD_APP_ID" ]; then
            echo "::error::Profile application-identifier ($PROFILE_APP_ID) does not match expected ($EXPECTED_APP_ID)."
            exit 1
          fi

          mkdir -p "$HOME/Library/MobileDevice/Provisioning Profiles"
          cp "$PROFILE_PATH" "$HOME/Library/MobileDevice/Provisioning Profiles/$PROFILE_UUID.mobileprovision"

          echo "PROFILE_UUID=$PROFILE_UUID" >> "$GITHUB_ENV"
          echo "PROFILE_NAME=$PROFILE_NAME" >> "$GITHUB_ENV"
          echo "PROFILE_TEAM_ID=$PROFILE_TEAM_ID" >> "$GITHUB_ENV"

      - name: Generate iOS native project if missing
        run: |
          set -euo pipefail
          if [ ! -d apps/mobile/ios ]; then
            cd apps/mobile
            npx expo prebuild --platform ios --non-interactive --no-install
          fi

      - name: Install CocoaPods dependencies
        run: |
          set -euo pipefail
          if [ ! -d apps/mobile/ios ]; then
            echo "::error::apps/mobile/ios still missing after prebuild."
            exit 1
          fi
          cd apps/mobile/ios
          pod install

      - name: Apply iOS version and build number
        run: |
          set -euo pipefail
          APP_INFO_PLIST="apps/mobile/ios/Mindwtr/Info.plist"
          if [ ! -f "$APP_INFO_PLIST" ]; then
            echo "::error::Info.plist not found at $APP_INFO_PLIST"
            exit 1
          fi
          /usr/libexec/PlistBuddy -c "Set :CFBundleShortVersionString $APP_VERSION" "$APP_INFO_PLIST" \
            || /usr/libexec/PlistBuddy -c "Add :CFBundleShortVersionString string $APP_VERSION" "$APP_INFO_PLIST"
          /usr/libexec/PlistBuddy -c "Set :CFBundleVersion $APP_BUILD_NUMBER" "$APP_INFO_PLIST" \
            || /usr/libexec/PlistBuddy -c "Add :CFBundleVersion string $APP_BUILD_NUMBER" "$APP_INFO_PLIST"
          echo "Info.plist version: $(/usr/libexec/PlistBuddy -c 'Print :CFBundleShortVersionString' "$APP_INFO_PLIST")"
          echo "Info.plist build: $(/usr/libexec/PlistBuddy -c 'Print :CFBundleVersion' "$APP_INFO_PLIST")"

      - name: Prepare ExportOptions.plist
        env:
          IOS_EXPORT_OPTIONS: ${{ secrets.IOS_EXPORT_OPTIONS }}
        run: |
          set -euo pipefail

          decode_base64() {
            local input="$1"
            local output="$2"
            if ! printf '%s' "$input" | tr -d '\r' | base64 --decode > "$output" 2>/dev/null; then
              printf '%s' "$input" | tr -d '\r' | base64 -D > "$output"
            fi
          }

          EXPORT_OPTIONS_PATH="$RUNNER_TEMP/ExportOptions.plist"
          if [ -n "${IOS_EXPORT_OPTIONS:-}" ]; then
            decode_base64 "$IOS_EXPORT_OPTIONS" "$EXPORT_OPTIONS_PATH"
          else
            {
              printf '%s\n' '<?xml version="1.0" encoding="UTF-8"?>'
              printf '%s\n' '<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">'
              printf '%s\n' '<plist version="1.0">'
              printf '%s\n' '<dict>'
              printf '%s\n' '    <key>method</key>'
              printf '%s\n' '    <string>app-store</string>'
              printf '%s\n' '    <key>destination</key>'
              printf '%s\n' '    <string>export</string>'
              printf '%s\n' '    <key>signingStyle</key>'
              printf '%s\n' '    <string>manual</string>'
              printf '%s\n' '    <key>teamID</key>'
              printf '    <string>%s</string>\n' "$PROFILE_TEAM_ID"
              printf '%s\n' '    <key>provisioningProfiles</key>'
              printf '%s\n' '    <dict>'
              printf '        <key>%s</key>\n' "$EXPECTED_BUNDLE_ID"
              printf '        <string>%s</string>\n' "$PROFILE_NAME"
              printf '%s\n' '    </dict>'
              printf '%s\n' '    <key>stripSwiftSymbols</key>'
              printf '%s\n' '    <true/>'
              printf '%s\n' '    <key>uploadSymbols</key>'
              printf '%s\n' '    <true/>'
              printf '%s\n' '</dict>'
              printf '%s\n' '</plist>'
            } > "$EXPORT_OPTIONS_PATH"
          fi
          echo "EXPORT_OPTIONS_PATH=$EXPORT_OPTIONS_PATH" >> "$GITHUB_ENV"

      - name: Archive iOS app
        run: |
          set -euo pipefail
          ARCHIVE_PATH="$RUNNER_TEMP/Mindwtr.xcarchive"
          xcodebuild \
            -workspace "apps/mobile/ios/Mindwtr.xcworkspace" \
            -scheme "Mindwtr" \
            -configuration "Release" \
            -sdk "iphoneos" \
            -destination "generic/platform=iOS" \
            -archivePath "$ARCHIVE_PATH" \
            CODE_SIGN_STYLE=Manual \
            DEVELOPMENT_TEAM="$PROFILE_TEAM_ID" \
            PRODUCT_BUNDLE_IDENTIFIER="$EXPECTED_BUNDLE_ID" \
            PROVISIONING_PROFILE_SPECIFIER="$PROFILE_NAME" \
            CODE_SIGN_IDENTITY="$IOS_SIGNING_IDENTITY" \
            OTHER_CODE_SIGN_FLAGS="--keychain $KEYCHAIN_PATH" \
            MARKETING_VERSION="$APP_VERSION" \
            CURRENT_PROJECT_VERSION="$APP_BUILD_NUMBER" \
            clean archive
          ARCHIVE_INFO_PLIST="$ARCHIVE_PATH/Products/Applications/Mindwtr.app/Info.plist"
          if [ ! -f "$ARCHIVE_INFO_PLIST" ]; then
            echo "::error::Archived app Info.plist not found: $ARCHIVE_INFO_PLIST"
            exit 1
          fi
          ARCHIVE_BUILD_NUMBER="$(/usr/libexec/PlistBuddy -c 'Print :CFBundleVersion' "$ARCHIVE_INFO_PLIST")"
          ARCHIVE_VERSION="$(/usr/libexec/PlistBuddy -c 'Print :CFBundleShortVersionString' "$ARCHIVE_INFO_PLIST")"
          echo "Archived app version: ${ARCHIVE_VERSION}"
          echo "Archived app build: ${ARCHIVE_BUILD_NUMBER}"
          if [ "$ARCHIVE_BUILD_NUMBER" != "$APP_BUILD_NUMBER" ]; then
            echo "::error::Archive build number mismatch (expected $APP_BUILD_NUMBER, got $ARCHIVE_BUILD_NUMBER)."
            exit 1
          fi
          echo "ARCHIVE_PATH=$ARCHIVE_PATH" >> "$GITHUB_ENV"

      - name: Export IPA
        run: |
          set -euo pipefail
          EXPORT_PATH="$RUNNER_TEMP/ios-export"
          xcodebuild -exportArchive \
            -archivePath "$ARCHIVE_PATH" \
            -exportPath "$EXPORT_PATH" \
            -exportOptionsPlist "$EXPORT_OPTIONS_PATH"
          IPA_PATH="$(find "$EXPORT_PATH" -maxdepth 1 -name '*.ipa' | head -n 1)"
          if [ -z "${IPA_PATH:-}" ]; then
            echo "::error::IPA was not generated."
            exit 1
          fi
          echo "IPA_PATH=$IPA_PATH" >> "$GITHUB_ENV"
          ls -la "$EXPORT_PATH"

      - name: Upload IPA to App Store Connect
        if: ${{ (github.event.inputs.upload || 'true') == 'true' }}
        env:
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_PASSWORD: ${{ secrets.APPLE_PASSWORD }}
        run: |
          set -euo pipefail
          xcrun altool --upload-app --type ios --file "$IPA_PATH" --username "$APPLE_ID" --password "$APPLE_PASSWORD"

      - name: Upload IPA artifact
        uses: actions/upload-artifact@v4
        with:
          name: mindwtr-ios-appstore-ipa
          path: ${{ env.IPA_PATH }}
          if-no-files-found: error

      - name: Cleanup signing files
        if: always()
        run: |
          if [ -n "${KEYCHAIN_PATH:-}" ] && [ -f "${KEYCHAIN_PATH}" ]; then
            security delete-keychain "$KEYCHAIN_PATH" || true
          fi
